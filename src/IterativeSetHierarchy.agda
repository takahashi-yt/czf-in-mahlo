{-# OPTIONS --cubical-compatible --safe #-}

module IterativeSetHierarchy where

open import Agda.Primitive
open import Agda.Builtin.Unit
open import Agda.Builtin.Bool
open import Agda.Builtin.Nat
open import Agda.Builtin.Sigma
open import Agda.Builtin.Equality
open import Preliminaries
open import CZFBasics
open import CZFAxioms
open import ExternalMahlo
open import TypeHierarchy


private variable
  a : ùïç
  t : Acc a
  c : ùîΩ 0


-- the type VÃÇ a t c as an iterative set in ùïç

V : (a : ùïç) (t : Acc a) (c : ùîΩ 0) ‚Üí ùïç 
V a t c = sup (VÃÇ a t c) (h a t c)

V-trans : isTransitive (V a t c)
V-trans {a} {t} {c} v w d e  =
  let Vtrans-lem : v ‚âê h a t c (sup (index (fst d)) (pred (fst d)))
      Vtrans-lem = ‚âêtrans v
                          (h a t c (fst d))
                          (h a t c (sup (index (fst d)) (pred (fst d))))
                          (snd d)
                          (fst h-iso (‚âê'eta {a} {t} {c} (fst d)))
  in pred (fst d) (fst (fst (‚âêext Vtrans-lem w) e)) ,
     snd (fst (‚âêext Vtrans-lem w) e)


-- V a t c is closed under singleton operation

V-sglt : (x : ùïç) ‚Üí x ‚àà V a t c ‚Üí sglt x ‚àà V a t c
V-sglt {a} {prog f} {c} x x-in-V =
  let x' : VÃÇ a (prog f) c
      x' = fst x-in-V
  in (sup code‚ä§ Œª _ ‚Üí x') , (Œª _ ‚Üí tt , snd x-in-V) , (Œª _ ‚Üí tt , snd x-in-V)

V-sglt' : ‚àÄùïß‚àà (V a t c) Œª x ‚Üí sglt x ‚àà V a t c
V-sglt' {a} {prog f} {c} i =
  (sup code‚ä§ Œª _ ‚Üí i) , (Œª _ ‚Üí tt , ‚âêrefl (h a (prog f) c i)) , Œª _ ‚Üí tt , ‚âêrefl (h a (prog f) c i)
  

-- we show that V a t c validates all axioms of CZF

-- V a t c validates Extensionality Axioms

V-ext : V a t c ‚äßExtAx
V-ext {a} {t} {c} = ((Œª v w x p d ‚Üí fst (h‚àà-iso {v = w} {w = x})
                                        (ExtAx1VÃÇ {a} {t} {c} {u = x} {v = v} {w = w} (snd (h-iso) p)
                                                                         (snd (h‚àà-iso {v = v} {w = x}) d))) ,
                    (Œª v w p x ‚Üí (Œª d ‚Üí fst (h‚àà-iso {v = x} {w = w})
                                            (fst (ExtAx2VÃÇ {a} {t} {c} {v = v} {w = w} (snd (h-iso {v = v} {w = w}) p) x)
                                                 (snd (h‚àà-iso {v = x} {w = v}) d))) ,
                                 Œª d ‚Üí fst (h‚àà-iso {v = x} {w = v})
                                           (snd (ExtAx2VÃÇ {a} {t} {c} {v = v} {w = w} (snd (h-iso {v = v} {w = w}) p) x)
                                                (snd (h‚àà-iso {v = x} {w = w}) d)))) ,
                    Œª v w d ‚Üí fst (h-iso {v = v} {w = w})
                                  (ExtAx2VÃÇ' {a} {t} {c} {v = v} {w = w} Œª x ‚Üí
                                                                          (Œª e ‚Üí snd (h‚àà-iso {v = x} {w = w})
                                                                                       (fst (d x) (fst (h‚àà-iso {v = x} {w = v}) e))) ,
                                                                          (Œª e ‚Üí snd (h‚àà-iso {v = x} {w = v})
                                                                                       (snd (d x) (fst (h‚àà-iso {v = x} {w = w}) e))))


-- V a t c validates Set Induction Axiom

V-set-ind : V a t c ‚äßSetInd
V-set-ind {a} {t} {c} F-inv IH (sup x f) = IH (sup x f) Œª z ‚Üí V-set-ind {a} {t} {c} F-inv IH (f z)

-- a parameterised formulation of models of Set Induction Axiom

[_,_,_]‚äßSetInd : (U : Set) (T : U ‚Üí Set) ‚Üí ùïç ‚Üí Set‚ÇÅ
[ U , T , w ]‚äßSetInd =
  (F : ùïç ‚Üí U) ‚Üí isInv (Œª x ‚Üí T (F x)) ‚Üí (‚àÄùïß‚àà w Œª a ‚Üí (‚àÄùïß‚àà a Œª v ‚Üí T (F v)) ‚Üí T (F a)) ‚Üí ‚àÄùïß‚àà w Œª a ‚Üí T (F a)

V-set-ind' : [ UÃÇ a t c , TÃÇ a t c , V a t c ]‚äßSetInd
V-set-ind' {a} {prog f} {c} F F-inv d =
  let F' : VÃÇ a (prog f) c ‚Üí UÃÇ a (prog f) c
      F' v = F (h a (prog f) c v)
  in SetIndVÃÇ {a} {prog f} {c} {F'}
             (Œª p d ‚Üí F-inv (fst (h-iso {a} {prog f} {c}) p) d)
              Œª v e ‚Üí d v Œª x ‚Üí F-inv (‚âêsym (pred (h a (prog f) c v) x)
                                            (pred (sup (TÃÇ a (prog f) c (index v)) (Œª y ‚Üí h a (prog f) c (pred v y)))
                                                  (fst (ip-compat (fst (h-iso {a} {prog f} {c} {v} {sup (index v) (pred v)})
                                                                         (‚âê'eta {a} {prog f} {c} v)) x)))
                                            (snd (ip-compat (fst (h-iso {a} {prog f} {c} {v} {sup (index v) (pred v)})
                                                                   (‚âê'eta {a} {prog f} {c} v)) x)))
                                      (e (pred v (fst (ip-compat (fst (h-iso {a} {prog f} {c} {v} {sup (index v) (pred v)})
                                                                        (‚âê'eta {a} {prog f} {c} v)) x)))
                                         (fst (ip-compat (fst (h-iso {a} {prog f} {c} {v} {sup (index v) (pred v)})
                                                                (‚âê'eta {a} {prog f} {c} v)) x) ,
                                          ‚âê'refl {a} {prog f} {c} (pred v (fst (ip-compat (fst (h-iso {a} {prog f} {c} {v} {sup (index v) (pred v)})
                                                                                                 (‚âê'eta {a} {prog f} {c} v)) x)))))


-- V a t c validates Pairing Axiom

V-pairing : V a t c ‚äßPairs
V-pairing {a} {prog f} {c} x y = fst (PairsVÃÇ {a} {prog f} {c} x y) ,
                                 Œª v ‚Üí (Œª d‚ÇÅ ‚Üí fst (h-iso‚äï {a} {prog f} {c})
                                                   (fst (snd (PairsVÃÇ {a} {prog f} {c} x y) v)
                                                        (snd (h‚àà-iso {a} {prog f} {c} {v}
                                                                     {sup codeB (Boolelim (Œª _ ‚Üí VÃÇ a (prog f) c) y x)}) d‚ÇÅ))) ,
                                       (Œª d‚ÇÇ ‚Üí fst (h‚àà-iso {a} {prog f} {c} {v}
                                                               {sup codeB (Boolelim (Œª _ ‚Üí VÃÇ a (prog f) c) y x)})
                                                     (snd (snd (PairsVÃÇ {a} {prog f} {c} x y) v)
                                                       (snd (h-iso‚äï {a} {prog f} {c}) d‚ÇÇ)))


-- V a t c validates Union Axiom

V-union : V a t c ‚äßUnion
V-union {a} {prog f} {c} x = let lem‚ÇÅ : (y : VÃÇ a (prog f) c)
                                          (d : pred (V a (prog f) c) y ‚àà pred (V a (prog f) c) (fst (UnionVÃÇ {a} {prog f} {c} x))) ‚Üí
                                            h a (prog f) c y ‚àà
                                              h a (prog f) c (pred x (fst (fst (snd (fst (snd (UnionVÃÇ {a} {prog f} {c} x) y)
                                                               (snd (h‚àà-iso {a} {prog f} {c} {y} {fst (UnionVÃÇ {a} {prog f} {c} x)}) d))))))
                                 lem‚ÇÅ y d = fst (h‚àà-iso {a} {prog f} {c} {y}
                                                        {pred x (fst (fst (snd (fst (snd (UnionVÃÇ {a} {prog f} {c} x) y)
                                                                    (snd (h‚àà-iso {a} {prog f} {c} {y}
                                                                      {fst (UnionVÃÇ {a} {prog f} {c} x)}) d)))))})
                                                  (fst (ExtAx2VÃÇ {a} {prog f} {c}
                                                                {fst (fst (snd (UnionVÃÇ {a} {prog f} {c} x) y)
                                                                            (snd (h‚àà-iso {a} {prog f} {c} {y}
                                                                                         {fst (UnionVÃÇ {a} {prog f} {c} x)}) d))}
                                                                {pred x (fst (fst (snd (fst (snd (UnionVÃÇ {a} {prog f} {c} x) y)
                                                                                              (snd (h‚àà-iso {a} {prog f} {c} {y}
                                                                                                           {fst (UnionVÃÇ {a} {prog f} {c} x)}) d)))))}
                                                                (snd (fst (snd (fst (snd (UnionVÃÇ {a} {prog f} {c} x) y)
                                                                                      (snd (h‚àà-iso {a} {prog f} {c} {y}
                                                                                                       {fst (UnionVÃÇ {a} {prog f} {c} x)}) d))))) y)
                                                         (snd (snd (fst (snd (UnionVÃÇ {a} {prog f} {c} x) y)
                                                                          (snd (h‚àà-iso {a} {prog f} {c} {y}
                                                                                       {fst (UnionVÃÇ {a} {prog f} {c} x)}) d)))))
                                 lem‚ÇÇ : (y : VÃÇ a (prog f) c)
                                          (d : pred (V a (prog f) c) y ‚àà pred (V a (prog f) c) (fst (UnionVÃÇ {a} {prog f} {c} x))) ‚Üí
                                            Œ£ (index (h a (prog f) c x))
                                              (Œª z ‚Üí h a (prog f) c (pred x (fst (fst (snd (fst (snd (UnionVÃÇ {a} {prog f} {c} x) y)
                                                                                (snd (h‚àà-iso {a} {prog f} {c} {y}
                                                                                  {fst (UnionVÃÇ {a} {prog f} {c} x)}) d))))))
                                                     ‚âê pred (h a (prog f) c x) z)
                                 lem‚ÇÇ y d = ip-compat (fst (h-iso {a} {prog f} {c} {sup (index x) (pred x)} {x})
                                                             (‚âê'sym {a} {prog f} {c} x (sup (index x) (pred x)) (‚âê'eta {a} {prog f} {c} x)))
                                                      (fst (fst (snd (fst (snd (UnionVÃÇ {a} {prog f} {c} x) y)
                                                                            (snd (h‚àà-iso {a} {prog f} {c} {y}
                                                                                         {fst (UnionVÃÇ {a} {prog f} {c} x)}) d)))))
                                 lem‚ÇÉ : (y : VÃÇ a (prog f) c) (z : index (pred (V a (prog f) c) x))
                                          (e : h a (prog f) c y ‚àà pred (h a (prog f) c x) z) ‚Üí
                                            Œ£ (TÃÇ a (prog f) c (index x))
                                              Œª u ‚Üí pred (h a (prog f) c x) z ‚âê h a (prog f) c (pred x u)
                                 lem‚ÇÉ y z e = ip-compat (fst (h-iso {a} {prog f} {c} {x} {sup (index x) (pred x)})
                                                               (‚âê'eta {a} {prog f} {c} x)) z
                             in fst (UnionVÃÇ {a} {prog f} {c} x) ,
                                Œª y ‚Üí (Œª d ‚Üí fst (lem‚ÇÇ y d) ,
                                             fst (‚âêext (snd (lem‚ÇÇ y d)) (h a (prog f) c y)) (lem‚ÇÅ y d)) ,
                                       Œª (z , e) ‚Üí fst (h‚àà-iso {a} {prog f} {c} {y} {fst (UnionVÃÇ {a} {prog f} {c} x)})
                                                         (snd (snd (UnionVÃÇ {a} {prog f} {c} x) y)
                                                           (pred x (fst (lem‚ÇÉ y z e)) ,
                                                             (fst (ip-compat (fst (h-iso {a} {prog f} {c} {x} {sup (index x) (pred x)})
                                                                                    (‚âê'eta {a} {prog f} {c} x)) z) ,
                                                              ‚âê'refl {a} {prog f} {c} (pred x (fst (ip-compat (fst (h-iso {a} {prog f} {c} {x}
                                                                                                                          {sup (index x) (pred x)})
                                                                                                                     (‚âê'eta {a} {prog f} {c} x)) z)))) ,
                                                             snd (h‚àà-iso {a} {prog f} {c} {y} {pred x (fst (lem‚ÇÉ y z e))})
                                                                   (fst (‚âêext (snd (lem‚ÇÉ y z e)) (h a (prog f) c y)) e)))


-- V a t c satisfies Restricted Separation Axiom

-- we need the parameters U and V in the definition of [_,_,_]‚äßSep in order to express the condition that F is restricted to w 

[_,_,_]‚äßSep : (U : Set) (T : U ‚Üí Set) ‚Üí ùïç ‚Üí Set‚ÇÅ
[ U , T , w ]‚äßSep =
  (F : ùïç ‚Üí U) ‚Üí isInv (Œª x ‚Üí T (F x)) ‚Üí ‚àÄùïß‚àà w Œª a ‚Üí ‚àÉùïß‚àà w Œª b ‚Üí ‚àÄùïß‚àà w Œª x ‚Üí x ‚àà b ‚Üî (x ‚àà a √ó T (F x))

V-sep : [ UÃÇ a t c , TÃÇ a t c , V a t c ]‚äßSep
V-sep {a} {prog f} {c} F F-inv x =
  let lem‚ÇÅ : Œ£ (VÃÇ a (prog f) c)
               Œª w ‚Üí (v : VÃÇ a (prog f) c) ‚Üí
                       TÃÇ a (prog f) c (‚àà' a (prog f) c v w) ‚Üî (TÃÇ a (prog f) c (‚àà' a (prog f) c v x) √ó TÃÇ a (prog f) c (F (h a (prog f) c v)))
      lem‚ÇÅ = SepAxVÃÇ {a} {prog f} {c} (Œª y ‚Üí F (h a (prog f) c y)) (Œª p ‚Üí F-inv (fst (h-iso {a} {prog f} {c}) p)) x
      lem‚ÇÇ : Œ£ (VÃÇ a (prog f) c)
               Œª w ‚Üí (v : VÃÇ a (prog f) c) ‚Üí
                       TÃÇ a (prog f) c (‚àà' a (prog f) c v w) ‚Üî
                       TÃÇ a (prog f) c (‚àÉùïß‚àà' a (prog f) c x (Œª z ‚Üí small√ó a (prog f) c (‚âê' a (prog f) c v z) (F (h a (prog f) c z))))
      lem‚ÇÇ = fst lem‚ÇÅ ,
             Œª v ‚Üí (Œª d ‚Üí fst (fst (fst (snd lem‚ÇÅ v) d)) ,
                            snd (fst (fst (snd lem‚ÇÅ v) d)) ,
                            F-inv (fst (h-iso {a} {prog f} {c}) (snd (fst (fst (snd lem‚ÇÅ v) d)))) (snd (fst (snd lem‚ÇÅ v) d)) ) ,
                    Œª e ‚Üí snd (snd lem‚ÇÅ v) ((fst e , fst (snd e)) ,
                                            F-inv (‚âêsym (h a (prog f) c v)
                                                        (h a (prog f) c (pred x (fst e)))
                                                        (fst (h-iso {a} {prog f} {c}) (fst (snd e))))
                                                  (snd (snd e)))
  in fst lem‚ÇÇ , Œª y ‚Üí (Œª d ‚Üí fst (h‚àà-iso {a} {prog f} {c} {y} {x})
                                   (fst (fst (snd lem‚ÇÇ y) (snd (h‚àà-iso {a} {prog f} {c} {y} {fst lem‚ÇÇ}) d)) ,
                                    fst (snd (fst (snd lem‚ÇÇ y) (snd (h‚àà-iso {a} {prog f} {c} {y} {fst lem‚ÇÇ}) d)))) ,
                             F-inv (fst (h-iso {a} {prog f} {c} {pred x (fst (fst (snd lem‚ÇÇ y)
                                          (snd (h‚àà-iso {a} {prog f} {c} {y} {fst lem‚ÇÇ}) d)))} {y})
                                        (‚âê'sym {a} {prog f} {c}
                                               y
                                               (pred x (fst (fst (snd lem‚ÇÇ y) (snd (h‚àà-iso {a} {prog f} {c} {y} {fst lem‚ÇÇ}) d))))
                                               (fst (snd (fst (snd lem‚ÇÇ y) (snd (h‚àà-iso {a} {prog f} {c} {y} {fst lem‚ÇÇ}) d))))))
                                   (snd (snd (fst (snd lem‚ÇÇ y) (snd (h‚àà-iso {a} {prog f} {c} {y} {fst lem‚ÇÇ}) d))))) ,
                      (Œª e ‚Üí fst (h‚àà-iso {a} {prog f} {c} {y} {fst lem‚ÇÇ})
                                   (snd (snd lem‚ÇÇ y)
                                          (fst (snd (h‚àà-iso {a} {prog f} {c} {y} {x}) (fst e)) ,
                                            snd (snd (h‚àà-iso {a} {prog f} {c} {y} {x}) (fst e)) ,
                                            F-inv (fst (h-iso {a} {prog f} {c} {y}
                                                                {pred x (fst (snd (h‚àà-iso {a} {prog f} {c} {y} {x}) (fst e)))})
                                                         (snd (snd (h‚àà-iso {a} {prog f} {c} {y} {x}) (fst e))))
                                                  (snd e))))


-- V a t c validates Strong Collection Axiom

V-strcoll : V a t c ‚äßStrColl
V-strcoll {a} {prog f} {c} F-inv1 F-inv2 v d =
  (sup (index v) Œª x ‚Üí fst (d (fst (lem‚ÇÅ x)))) ,
    (Œª x ‚Üí fst (lem‚ÇÇ x) , F-inv1 (h a (prog f) c (fst (d (fst (lem‚ÇÅ (fst (lem‚ÇÇ x)))))))
                                 (‚âêtrans (pred (h a (prog f) c v) (fst (lem‚ÇÅ (fst (lem‚ÇÇ x)))))
                                         (h a (prog f) c (pred v (fst (lem‚ÇÇ x))))
                                         (pred (h a (prog f) c v) x)
                                         (‚âêsym (h a (prog f) c (pred v (fst (lem‚ÇÇ x))))
                                               (pred (h a (prog f) c v) (fst (lem‚ÇÅ (fst (lem‚ÇÇ x)))))
                                               (snd (lem‚ÇÅ (fst (lem‚ÇÇ x)))))
                                         (‚âêsym (pred (h a (prog f) c v) x)
                                                (h a (prog f) c (pred v (fst (lem‚ÇÇ x))))
                                                (snd (lem‚ÇÇ x))))
                                 (snd (d (fst (lem‚ÇÅ (fst (lem‚ÇÇ x))))))) ,
    (Œª y ‚Üí fst (lem‚ÇÅ y) , snd (d (fst (lem‚ÇÅ y))))
  where
  lem‚ÇÅ : (x : TÃÇ a (prog f) c (index v)) ‚Üí h a (prog f) c (pred v x) ‚àà h a (prog f) c v 
  lem‚ÇÅ x = fst (h‚àà-iso {a} {prog f} {c} {pred v x} {v}) (x , ‚âê'refl {a} {prog f} {c} (pred v x))

  lem‚ÇÇ : (x : index (h a (prog f) c v)) ‚Üí Œ£ (TÃÇ a (prog f) c (index v)) Œª y ‚Üí
           pred (h a (prog f) c v) x ‚âê h a (prog f) c (pred v y)
  lem‚ÇÇ x = ip-compat (fst (h-iso {a} {prog f} {c} {v} {sup (index v) (pred v)}) (‚âê'eta {a} {prog f} {c} v)) x

-- a parameterised formulation of Strong Collection Axiom

[_,_,_]‚äßStrColl : (U : Set) ‚Üí (T : U ‚Üí Set) ‚Üí ùïç ‚Üí Set‚ÇÅ
[ U , T , v ]‚äßStrColl = {F : ùïç ‚Üí ùïç ‚Üí U} ‚Üí
                          ((w‚ÇÇ : ùïç) ‚Üí isInv (Œª w‚ÇÅ ‚Üí T (F w‚ÇÅ w‚ÇÇ))) ‚Üí ((w‚ÇÅ : ùïç) ‚Üí isInv (Œª w‚ÇÇ ‚Üí T (F w‚ÇÅ w‚ÇÇ))) ‚Üí
                            ‚àÄùïß‚àà v (Œª a ‚Üí (‚àÄùïß‚àà a Œª v‚ÇÅ ‚Üí ‚àÉùïß‚àà v Œª v‚ÇÇ ‚Üí T (F v‚ÇÅ v‚ÇÇ)) ‚Üí
                              ‚àÉùïß‚àà v Œª b ‚Üí (‚àÄùïß‚àà a Œª v‚ÇÅ ‚Üí ‚àÉùïß‚àà b Œª v‚ÇÇ ‚Üí T (F v‚ÇÅ v‚ÇÇ)) √ó (‚àÄùïß‚àà b Œª v‚ÇÇ ‚Üí ‚àÉùïß‚àà a Œª v‚ÇÅ ‚Üí T (F v‚ÇÅ v‚ÇÇ)))

V-strcoll' : [ UÃÇ a t c , TÃÇ a t c , V a t c ]‚äßStrColl
V-strcoll' {a} {prog f} {c} {F} F-inv1 F-inv2 v d =
  let lem‚ÇÅ : Œ£ (VÃÇ a (prog f) c)
                Œª w ‚Üí
                  TÃÇ a (prog f) c (‚àÄùïß‚àà' a (prog f) c v (Œª x ‚Üí ‚àÉùïß‚àà' a (prog f) c w (Œª y ‚Üí F (h a (prog f) c x) (h a (prog f) c y))))
                  √ó
                  TÃÇ a (prog f) c (‚àÄùïß‚àà' a (prog f) c w (Œª y ‚Üí ‚àÉùïß‚àà' a (prog f) c v (Œª x ‚Üí F (h a (prog f) c x) (h a (prog f) c y))))
      lem‚ÇÅ = StrCollVÃÇ {a} {prog f} {c} {Œª x y ‚Üí F (h a (prog f) c x) (h a (prog f) c y)} {v}
                       Œª x e ‚Üí fst (d (fst (fst (h‚àà-iso {a} {prog f} {c} {x} {v}) e))) ,
                               F-inv1 (h a (prog f) c (fst (d (fst (fst (h‚àà-iso {a} {prog f} {c} {x} {v}) e)))))
                                      (‚âêsym (h a (prog f) c x)
                                            (pred (h a (prog f) c v) (fst (fst (h‚àà-iso {a} {prog f} {c} {x} {v}) e)))
                                            (snd (fst (h‚àà-iso {a} {prog f} {c} {x} {v}) e)))
                                      (snd (d (fst (fst (h‚àà-iso {a} {prog f} {c} {x} {v} ) e))))
      lem‚ÇÇ : (w : VÃÇ a (prog f) c) (x : index (h a (prog f) c w)) ‚Üí
               Œ£ (index (sup (TÃÇ a (prog f) c (index w)) (Œª y ‚Üí h a (prog f) c (pred w y))))
                   Œª y ‚Üí
                    pred (h a (prog f) c w) x ‚âê
                    pred (sup (TÃÇ a (prog f) c (index w)) (Œª y‚ÇÅ ‚Üí h a (prog f) c (pred w y‚ÇÅ))) y
      lem‚ÇÇ w x = ip-compat (fst (h-iso {a} {prog f} {c} {w} {sup (index w) (pred w)})
                                (‚âê'eta {a} {prog f} {c} w))
                            x
      lem‚ÇÉ : (w : VÃÇ a (prog f) c) (x : index (h a (prog f) c w)) ‚Üí
               TÃÇ a (prog f) c (‚àà' a (prog f) c (pred w (fst (ip-compat
                                   (fst (h-iso {a} {prog f} {c} {w} {sup (index w) (pred w)})
                                     (‚âê'eta {a} {prog f} {c} w)) x)))
                                  w)
      lem‚ÇÉ w x = snd (h‚àà-iso {a} {prog f} {c}
                       {pred w (fst (ip-compat
                         (fst (h-iso {a} {prog f} {c} {w} {sup (index w) (pred w)})
                           (‚âê'eta {a} {prog f} {c} w)) x))} {w})
                     (x , ‚âêsym (pred (h a (prog f) c w) x)
                               (h a (prog f) c (pred w (fst (ip-compat
                                          (fst (h-iso {a} {prog f} {c} {w} {sup (index w) (pred w)})
                                            (‚âê'eta {a} {prog f} {c} w)) x))))
                               (snd (lem‚ÇÇ w x)))
      lem‚ÇÑ : (x : index (h a (prog f) c v)) ‚Üí
               h a (prog f) c (pred (fst lem‚ÇÅ) (fst (fst (snd lem‚ÇÅ) (fst (lem‚ÇÉ v x))))) ‚àà
                 h a (prog f) c (fst lem‚ÇÅ)
      lem‚ÇÑ x = fst (h‚àà-iso {a} {prog f} {c}
                     {pred (fst lem‚ÇÅ) (fst (fst (snd lem‚ÇÅ) (fst (lem‚ÇÉ v x))))} {fst lem‚ÇÅ})
                   (fst (fst (snd lem‚ÇÅ) (fst (lem‚ÇÉ v x))) ,
                    ‚âê'refl {a} {prog f} {c} (pred (fst lem‚ÇÅ) (fst (fst (snd lem‚ÇÅ) (fst (lem‚ÇÉ v x))))))
      lem‚ÇÖ : (y : index (h a (prog f) c (fst lem‚ÇÅ))) ‚Üí
               h a (prog f) c (pred v (fst (snd (snd lem‚ÇÅ) (fst (lem‚ÇÉ (fst lem‚ÇÅ) y))))) ‚àà
                 h a (prog f) c v
      lem‚ÇÖ y = fst (h‚àà-iso {a} {prog f} {c}
                     {pred v (fst (snd (snd lem‚ÇÅ) (fst (lem‚ÇÉ (fst lem‚ÇÅ) y))))} {v})
                   (fst (snd (snd lem‚ÇÅ) (fst (lem‚ÇÉ (fst lem‚ÇÅ) y))) ,
                    ‚âê'refl {a} {prog f} {c} (pred v (fst (snd (snd lem‚ÇÅ) (fst (lem‚ÇÉ (fst lem‚ÇÅ) y))))))
  in fst lem‚ÇÅ ,
       (Œª x ‚Üí fst (lem‚ÇÑ x) ,
              F-inv1 (pred (h a (prog f) c (fst lem‚ÇÅ)) (fst (lem‚ÇÑ x)))
                     (‚âêtrans (h a (prog f) c (pred v (fst (lem‚ÇÉ v x))))
                             (h a (prog f) c (pred v (fst (lem‚ÇÇ v x))))
                             (pred (h a (prog f) c v) x)
                             (‚âêsym (h a (prog f) c (pred v (fst (lem‚ÇÇ v x))))
                                   (h a (prog f) c (pred v (fst (lem‚ÇÉ v x))))
                                   (fst (h-iso {a} {(prog f)} {c} {pred v (fst (lem‚ÇÇ v x))} {pred v (fst (lem‚ÇÉ v x))})
                                        (snd (lem‚ÇÉ v x))))
                             (‚âêsym (pred (h a (prog f) c v) x)
                                   (h a (prog f) c (pred v (fst (lem‚ÇÇ v x))))
                                   (snd (lem‚ÇÇ v x))))
                     (F-inv2 (h a (prog f) c (pred v (fst (lem‚ÇÉ v x))))
                             (snd (lem‚ÇÑ x))
                             (snd (fst (snd lem‚ÇÅ) (fst (lem‚ÇÉ v x)))))) ,
       (Œª y ‚Üí fst (lem‚ÇÖ y) ,
              F-inv2 (pred (h a (prog f) c v) (fst (lem‚ÇÖ y)))
                     (‚âêtrans (h a (prog f) c (pred (fst lem‚ÇÅ) (fst (lem‚ÇÉ (fst lem‚ÇÅ) y))))
                             (h a (prog f) c (pred (fst lem‚ÇÅ) (fst (lem‚ÇÇ (fst lem‚ÇÅ) y))))
                             (pred (h a (prog f) c (fst lem‚ÇÅ)) y)
                             (‚âêsym (h a (prog f) c (pred (fst lem‚ÇÅ) (fst (lem‚ÇÇ (fst lem‚ÇÅ) y))))
                                   (h a (prog f) c (pred (fst lem‚ÇÅ) (fst (lem‚ÇÉ (fst lem‚ÇÅ) y))))
                                   (fst (h-iso {a} {prog f} {c} {pred (fst lem‚ÇÅ) (fst (lem‚ÇÇ (fst lem‚ÇÅ) y))}
                                                           {pred (fst lem‚ÇÅ) (fst (lem‚ÇÉ (fst lem‚ÇÅ) y))})
                                        (snd (lem‚ÇÉ (fst lem‚ÇÅ) y))))
                             (‚âêsym (pred (h a (prog f) c (fst lem‚ÇÅ)) y)
                                   (h a (prog f) c (pred (fst lem‚ÇÅ) (fst (lem‚ÇÇ (fst lem‚ÇÅ) y))))
                                   (snd (lem‚ÇÇ (fst lem‚ÇÅ) y))))
                     (F-inv1 (h a (prog f) c (pred (fst lem‚ÇÅ) (fst (lem‚ÇÉ (fst lem‚ÇÅ) y))))
                             (snd (lem‚ÇÖ y))
                             (snd (fst (snd lem‚ÇÅ) (fst (lem‚ÇÉ (fst lem‚ÇÅ) y))))))


-- V a t c validates Subset Collection Axiom

V-subcoll : V a t c ‚äßSubColl
V-subcoll {a} {prog g} {c} {F} F-inv1 F-inv2 v w =
  let hv : (x : TÃÇ a (prog g) c (index v)) ‚Üí h a (prog g) c (pred v x) ‚àà h a (prog g) c v
      hv x = fst (h‚àà-iso {a} {prog g} {c} {pred v x} {v}) (x , ‚âê'refl {a} {prog g} {c} (pred v x))

      u : VÃÇ a (prog g) c
      u = sup (codeŒ† (index v) (Œª _ ‚Üí index w)) (Œª f ‚Üí sup (index v) Œª x‚ÇÅ ‚Üí pred w (f x‚ÇÅ))

      lem‚ÇÄ : (x : index (h a (prog g) c v)) ‚Üí Œ£ (TÃÇ a (prog g) c (index v)) Œª y ‚Üí
               pred (h a (prog g) c v) x ‚âê h a (prog g) c (pred v y)
      lem‚ÇÄ x = ip-compat (fst (h-iso {a} {prog g} {c} {v} {sup (index v) (pred v)}) (‚âê'eta {a} {prog g} {c} v)) x

      lem‚ÇÅ : (y : index (h a (prog g) c w)) ‚Üí
               pred (h a (prog g) c w) y ‚àà sup (TÃÇ a (prog g) c (index w)) (Œª z ‚Üí h a (prog g) c (pred w z))
      lem‚ÇÅ y = fst (ExtAx2 (fst (h-iso {a} {prog g} {c} {w} {sup (index w) (pred w)})
                                  (‚âê'eta {a} {prog g} {c} w))
                           (pred (h a (prog g) c w) y))
                     (y , ‚âêrefl (pred (h a (prog g) c w) y))

      f' : (z : VÃÇ a (prog g) c) ‚Üí
             (f : ‚àÄùïß‚àà (pred (V a (prog g) c) v) Œª x ‚Üí
               ‚àÉùïß‚àà (pred (V a (prog g) c) w) Œª y ‚Üí
                 F x y (pred (V a (prog g) c) z)) ‚Üí
             (i : TÃÇ a (prog g) c (index v)) ‚Üí
               Œ£ (TÃÇ a (prog g) c (index w)) Œª j ‚Üí
                 F (h a (prog g) c (pred v i)) (h a (prog g) c (pred w j)) (h a (prog g) c z)
      f' z f i = fst (lem‚ÇÅ (fst (f (fst (hv i))))) ,
                 F-inv2 (h a (prog g) c (pred v i))
                        (h a (prog g) c z)
                        (snd (lem‚ÇÅ (fst (f (fst (hv i))))))
                        (F-inv1 (pred (h a (prog g) c w)
                                (fst (f (fst (fst (h‚àà-iso {a} {prog g} {c} {pred v i} {v})
                                  (i , ‚âê'refl {a} {prog g} {c} (pred v i)))))))
                                (h a (prog g) c z)
                                (‚âêsym (h a (prog g) c (pred v i))
                                      (pred (h a (prog g) c v) (fst (fst (h‚àà-iso {a} {prog g} {c} {pred v i} {v})
                                        (i , ‚âê'refl {a} {prog g} {c} (pred v i)))))
                                      (snd (hv i)))
                                (snd (f (fst (hv i)))))

      lem‚ÇÇ : (z : VÃÇ a (prog g) c) ‚Üí
              (f : ‚àÄùïß‚àà (pred (V a (prog g) c) v) Œª x ‚Üí
                     ‚àÉùïß‚àà (pred (V a (prog g) c) w) Œª y ‚Üí
                       F x y (pred (V a (prog g) c) z)) ‚Üí
                h a (prog g) c (pred u Œª i ‚Üí fst (f' z f i)) ‚àà h a (prog g) c u
      lem‚ÇÇ z f = fst (h‚àà-iso {a} {prog g} {c} {pred u Œª i ‚Üí fst (f' z f i)} {u})
                       ((Œª i ‚Üí fst (f' z f i)) ,
                        ‚âê'refl {a} {prog g} {c} (pred u Œª i ‚Üí fst (f' z f i)))
  in u , Œª z f ‚Üí fst (lem‚ÇÇ z f) ,
                   (Œª x ‚Üí fst (lem‚ÇÄ x) ,
                          F-inv1 (h a (prog g) c (pred w (fst (f' z f (fst (lem‚ÇÄ x))))))
                                  (h a (prog g) c z)
                                  (‚âêsym (pred (h a (prog g) c v) x)
                                  (h a (prog g) c (pred v (fst (ip-compat
                                                  (fst (h-iso {a} {prog g} {c} {v} {sup (index v) (pred v)})
                                                    (‚âê'eta {a} {prog g} {c} v)) x))))
                                  (snd (lem‚ÇÄ x)))
                                  (snd (f' z f (fst (lem‚ÇÄ x))))) ,
                   Œª x ‚Üí fst (hv x) ,
                         F-inv1 (h a (prog g) c (pred w (fst (lem‚ÇÅ (fst (f (fst (fst (h‚àà-iso {a} {prog g} {c} {pred v x} {v})
                                  (x , ‚âê'refl {a} {prog g} {c} (pred v x))))))))))
                                (h a (prog g) c z)
                                (snd (hv x))
                                (snd (f' z f x))

-- a parameterised formulation of Subset Collection Axiom

[_,_,_]‚äßSubColl : (U : Set) (T : U ‚Üí Set) ‚Üí ùïç ‚Üí Set‚ÇÅ
[ U , T , b ]‚äßSubColl = {F : (x y z : ùïç) ‚Üí U} ‚Üí
                          ‚àÄùïß‚àà b Œª v ‚Üí ‚àÄùïß‚àà b Œª w ‚Üí ‚àÉùïß‚àà b Œª u ‚Üí ‚àÄùïß‚àà b Œª z ‚Üí
                            (‚àÄùïß‚àà v Œª x ‚Üí ‚àÉùïß‚àà w Œª y ‚Üí T (F x y z)) ‚Üí ‚àÉùïß‚àà b Œª b' ‚Üí
                              b' ‚àà u √ó
                              (‚àÄùïß‚àà v Œª x ‚Üí ‚àÉùïß‚àà b' Œª y ‚Üí T (F x y z)) √ó
                              (‚àÄùïß‚àà b' Œª y ‚Üí ‚àÉùïß‚àà v Œª x ‚Üí T (F x y z))


-- V a t c validates Infinity Axiom

V-infty : V a t c ‚äßInfty
V-infty {a} {prog f} {c} = (‚àÖVÃÇ a (prog f) c , lem‚ÇÅ) ,
                           Œª v ‚Üí sucVÃÇ a (prog f) c v ,
                             lem‚ÇÇ v ,
                             lem‚ÇÉ v
  where
  lem‚ÇÅ : ((x : ‚ä•) ‚Üí Œ£ ‚ä• Œª y ‚Üí
           h a (prog f) c (‚ä•elim (Œª _ ‚Üí VÃÇ a (prog f) c) x) ‚âê ‚ä•elim (Œª _ ‚Üí ùïç) y) √ó
         ((y : ‚ä•) ‚Üí Œ£ ‚ä• Œª x ‚Üí
           h a (prog f) c (‚ä•elim (Œª _ ‚Üí VÃÇ a (prog f) c) x) ‚âê ‚ä•elim (Œª _ ‚Üí ùïç) y)
  lem‚ÇÅ = ‚ä•elim (Œª x ‚Üí Œ£ ‚ä• Œª y ‚Üí h a (prog f) c (‚ä•elim (Œª _ ‚Üí VÃÇ a (prog f) c) x) ‚âê ‚ä•elim (Œª _ ‚Üí ùïç) y) ,
         ‚ä•elim (Œª y ‚Üí Œ£ ‚ä• Œª x ‚Üí h a (prog f) c (‚ä•elim (Œª _ ‚Üí VÃÇ a (prog f) c) x) ‚âê ‚ä•elim (Œª _ ‚Üí ùïç) y)

  lem‚ÇÇ : (v : VÃÇ a (prog f) c) (x : TÃÇ a (prog f) c (codeS (index v) code‚ä§)) ‚Üí
           Œ£ (index (h a (prog f) c v) ‚äï ‚ä§) Œª y ‚Üí
             h a (prog f) c (‚äïelim (Œª _ ‚Üí VÃÇ a (prog f) c) (pred v) (Œª z ‚Üí v) x) ‚âê
             ‚äïelim (Œª _ ‚Üí ùïç) (pred (h a (prog f) c v)) (Œª z ‚Üí h a (prog f) c v) y
  lem‚ÇÇ v (injl x) =
    let sublem : h a (prog f) c (pred v x) ‚àà h a (prog f) c v
        sublem = fst (h‚àà-iso {a} {prog f} {c} {pred v x} {v}) (x , ‚âê'refl {a} {prog f} {c} (pred v x))
    in injl (fst sublem) , snd sublem
  lem‚ÇÇ v (injr one) = injr one , ‚âêrefl (h a (prog f) c v)

  lem‚ÇÉ : (v : VÃÇ a (prog f) c) (y : index (h a (prog f) c v) ‚äï ‚ä§) ‚Üí
           Œ£ (TÃÇ a (prog f) c (codeS (index v) code‚ä§)) Œª x ‚Üí
             h a (prog f) c (‚äïelim (Œª _ ‚Üí VÃÇ a (prog f) c) (pred v) (Œª z ‚Üí v) x) ‚âê
             ‚äïelim (Œª _ ‚Üí ùïç) (pred (h a (prog f) c v)) (Œª z ‚Üí h a (prog f) c v) y
  lem‚ÇÉ v (injl y) =
    let sublem‚ÇÅ : Œ£ (TÃÇ a (prog f) c (index v)) Œª z ‚Üí
                    pred (h a (prog f) c v) y ‚âê h a (prog f) c (pred v z)
        sublem‚ÇÅ = ip-compat (fst (h-iso {a} {prog f} {c} {v} {sup (index v) (pred v)}) (‚âê'eta {a} {prog f} {c} v)) y

        sublem‚ÇÇ : Œ£ (VÃÇ a (prog f) c) Œª w ‚Üí TÃÇ a (prog f) c (‚àà' a (prog f) c w v)
        sublem‚ÇÇ = pred v (fst sublem‚ÇÅ) , fst sublem‚ÇÅ , ‚âê'refl {a} {prog f} {c} (pred v (fst sublem‚ÇÅ))
    in injl (fst (snd sublem‚ÇÇ)) , ‚âêsym (pred (h a (prog f) c v) y) (h a (prog f) c (pred v (fst sublem‚ÇÅ))) (snd sublem‚ÇÅ)
  lem‚ÇÉ v (injr one) = injr one , ‚âêrefl (h a (prog f) c v)
  

-- V a t c is a model of CZF

[_,_,_]‚äßCZF : (U : Set) (T : U ‚Üí Set) ‚Üí ùïç ‚Üí Set‚ÇÅ
[ U , T , v ]‚äßCZF = (v ‚äßExtAx) √ó (v ‚äßSetInd) √ó (v ‚äßPairs) √ó (v ‚äßUnion) √ó [ U , T , v ]‚äßSep √ó (v ‚äßStrColl) √ó (v ‚äßSubColl) √ó (v ‚äßInfty)

V-czf : [ UÃÇ a t c , TÃÇ a t c , V a t c ]‚äßCZF
V-czf = ((((((V-ext , V-set-ind) , V-pairing) , V-union) , V-sep) , V-strcoll) , V-subcoll) , V-infty
